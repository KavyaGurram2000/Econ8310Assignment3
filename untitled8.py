# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19nFlZXIjxutbkih3EI1jH-eDBSQcLhzk
"""

import torch
import torch.nn as nn
import torch.optim as optim
from torchvision import transforms, datasets
from torch.utils.data import DataLoader

class FastFashionNet(nn.Module):
    def __init__(self):
        super(FastFashionNet, self).__init__()
        self.network = nn.Sequential(
            nn.Conv2d(1, 32, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Conv2d(32, 64, 3, padding=1),
            nn.ReLU(),
            nn.MaxPool2d(2),
            nn.Flatten(),
            nn.Linear(64 * 7 * 7, 128),
            nn.ReLU(),
            nn.Linear(128, 10)
        )

    def forward(self, x):
        return self.network(x)

def train_and_save():
    # Set device
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    print(f"Using device: {device}")

    # Create data loaders
    transform = transforms.Compose([
        transforms.ToTensor(),
        transforms.Normalize((0.2860,), (0.3530,))
    ])

    train_data = datasets.FashionMNIST(
        root='./data',
        train=True,
        transform=transform,
        download=True
    )

    train_loader = DataLoader(train_data, batch_size=64, shuffle=True)

    # Create model, loss function, and optimizer
    model = FastFashionNet().to(device)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    # Train for 3 epochs (quick training for demonstration)
    print("Training started...")
    for epoch in range(3):
        model.train()
        for batch_idx, (data, target) in enumerate(train_loader):
            data, target = data.to(device), target.to(device)
            optimizer.zero_grad()
            output = model(data)
            loss = criterion(output, target)
            loss.backward()
            optimizer.step()

            if batch_idx % 100 == 0:
                print(f'Epoch {epoch+1}: [{batch_idx * len(data)}/{len(train_loader.dataset)}] Loss: {loss.item():.4f}')

    # Save the model weights
    torch.save(model.state_dict(), 'fashion_mnist_weights.pth')
    print("Training completed and weights saved!")
    return model

def evaluate_model(model=None):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

    if model is None:
        model = FastFashionNet().to(device)
        model.load_state_dict(torch.load("fashion_mnist_weights.pth", map_location=device))

    model.eval()

    # Load test data
    test_data = datasets.FashionMNIST(
        root='./data',
        train=False,
        transform=transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize((0.2860,), (0.3530,))
        ]),
        download=True
    )
    test_loader = DataLoader(test_data, batch_size=128, shuffle=False)

    # Evaluate
    correct = 0
    total = 0
    class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
                  'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

    with torch.no_grad():
        for images, labels in test_loader:
            images, labels = images.to(device), labels.to(device)
            outputs = model(images)
            _, predicted = outputs.max(1)
            total += labels.size(0)
            correct += predicted.eq(labels).sum().item()

    accuracy = 100 * correct / total
    print(f"Test Accuracy: {accuracy:.2f}%")
    return accuracy

if __name__ == "__main__":
    # Train model and save weights
    model = train_and_save()

    # Evaluate the model
    evaluate_model(model)